// Read ROOT trees 
// Sam Grant

#include <iostream>
#include <vector>

#include "Plotter.h"
#include "TFile.h"
#include "TTree.h"
#include "TTreeReader.h"
#include "TH1D.h"
#include "TH2D.h"
#include "TMath.h"
#include "TVector3.h"
#include "TLorentzVector.h"
#include "Math/Vector3D.h"
#include "Math/Vector4D.h"
#include "TRandom3.h"

using namespace std;

double omegaAMagic = 0.00143934; // from gm2geom consts / kHz 
double g2Period = (2*TMath::Pi()/omegaAMagic) * 1e-3; // 4.3653239 us
double mMu = 105.6583715; // MeV
double aMu = 11659208.9e-10; 
double gmagic = std::sqrt( 1.+1./aMu );
double pmax = 1.01 * mMu * gmagic;
double eMass = 0.510999;
double T_c = 149.2 * 1e-3; // cyclotron period [us]

double pLo = 750; 
double pHi = 2750;

TTree *InitTree(string fileName, string treeName) { 

  // ++++++++++++++ Open tree and load branches ++++++++++++++
  // Get file
  TFile *fin = TFile::Open(fileName.c_str());
  cout<<"\nOpened tree:\t"<<fileName<<" "<<fin<<endl;

  // Get tree
  TTree *tree = (TTree*)fin->Get(treeName.c_str());

  cout<<"\nOpened tree:"<<treeName<<" "<<tree<<" from file "<<fileName<<" "<<fin<<endl;

  return tree;

}

double ModTime(double time, int nPeriods = 1) {

  double g2fracTime = time / (nPeriods * g2Period);
  int g2fracTimeInt = int(g2fracTime);
  double g2ModTime = (g2fracTime - g2fracTimeInt) * nPeriods * g2Period;

  return g2ModTime;

}

double RandomisedTime(TRandom3 *rand, double time) { 
  return rand->Uniform(time-T_c/2, time+T_c/2);
}

double AcceptanceWeightedAngle(TH2D *map, double theta_y, double y) { 

  int i = map->GetXaxis()->FindBin(y);
  int j = map->GetYaxis()->FindBin(theta_y);

  double weighting = map->GetBinContent(i, j);

  //double weighting_error = map->GetBinError(i, j);
  //cout<<"weighting: "<<weighting<<endl;

  return theta_y * weighting;


}

double AcceptanceWeightedAngleWithInterpolation(TH2D *map1, TH2D *map2, double theta_y, double y) { 

  // Get coordinates
  int i = map1->GetXaxis()->FindBin(y);
  int j = map1->GetYaxis()->FindBin(theta_y);

  // Get main weighting
  double weighting1 = map1->GetBinContent(i, j);
  //double err_weighting1 = map1->GetBinError(i, j);

  if(isnan(weighting1)) return theta_y;

  // For min/max momentum 
  if(map2==0) return theta_y * weighting1;

  // Get secondary weighting 

  // Get coordinates
  int i2 = map2->GetXaxis()->FindBin(y);
  int j2 = map2->GetYaxis()->FindBin(theta_y);

  double weighting2 = map2->GetBinContent(i2, j2);

  // Interpolate
  double weighting = (weighting1 + weighting2)/2;

  if(isnan(weighting)) {
    //cout<<"WARNING: acceptance wieghting is nan"<<endl;
    return theta_y;
  }

  //cout<<theta_y * weighting<<endl;
  //cout<<weighting<<endl;

  return theta_y * weighting;


}
/*
// With data driven acceptance corrections
void RunWithDataDrivenAcceptanceCorrection(TTree *tree, TFile *output, string config, bool momCuts, bool timeCuts, bool boost, bool verticalOffsetCorrection, bool acceptanceCorr) {

  // Vertical offset correction histograms
  TString verticalOffsetFileName = "correctionHists/verticalOffsetHists_allDecays_WORLD_250MeV_AQ.root";
  TFile *verticalOffsetFile = TFile::Open(verticalOffsetFileName);
  TH1D *verticalOffsetHist = (TH1D*)verticalOffsetFile->Get("VerticalOffsetHists/ThetaY_vs_p");

  // Acceptance correction histograms
  TString acceptanceFileName = "correctionHists/acceptanceWeightingPlots_"+config+".root";
  TFile *acceptanceFile = TFile::Open(acceptanceFileName);

  // Set the number of periods for the longer modulo plots
  int moduloMultiple = 4; 

  // Somewhat arbitrary 
  double boostFactor = 5e3*(1/gmagic);
  double momBoostFactor = 1.;

  if(boost) { 
    boostFactor = 1.0e3;
    momBoostFactor = (1/(2*gmagic));
  }

  string stns[] = {"S12", "S18", "S12S18"}; 
  int n_stn = sizeof(stns)/sizeof(stns[0]);

  // Slice momentum
  int step = 250 * momBoostFactor;
  int nSlices = (pmax/step) * momBoostFactor; 

  // ------------- Book histograms -------------

  TH1D *momentum_[n_stn];
  TH1D *momY_[n_stn];
  TH1D *momX_[n_stn];
  TH1D *momZ_[n_stn];
  TH2D *decayZ_vs_decayX_[n_stn];
  TH1D *wiggle_[n_stn];
  TH1D *wiggle_mod_[n_stn];
  TH1D *wiggle_mod_long_[n_stn];
  TH1D *thetaY_[n_stn];
  TH2D *thetaY_vs_time_[n_stn];
  TH2D *thetaY_vs_time_20ns_[n_stn];
  TH2D *thetaY_vs_time_50ns_[n_stn];
  TH2D *thetaY_vs_time_mod_[n_stn];
  TH2D *thetaY_vs_time_mod_20ns_[n_stn];
  TH2D *thetaY_vs_time_mod_50ns_[n_stn];
  TH2D *thetaY_vs_time_mod_long_[n_stn];
  TH2D *thetaY_vs_time_mod_long_20ns_[n_stn];
  TH2D *thetaY_vs_time_mod_long_50ns_[n_stn];
  TH2D *thetaY_vs_momentum_[n_stn];
  TH2D *thetaY_vs_Y_[n_stn]; 

  vector<TH1D*> thetaY_mom_slices_[n_stn];
  vector<TH1D*> Y_mom_slices_[n_stn];
  vector<TH1D*> pY_mom_slices_[n_stn];
  vector<TH1D*> p_mom_slices_[n_stn];
  vector<TH2D*> thetaY_vs_time_mod_slices_[n_stn];
  vector<TH2D*> thetaY_vs_time_mod_20ns_slices_[n_stn];
  vector<TH2D*> thetaY_vs_time_mod_50ns_slices_[n_stn];
  vector<TH2D*> thetaY_vs_time_mod_long_slices_[n_stn];
  vector<TH2D*> thetaY_vs_time_mod_long_20ns_slices_[n_stn];
  vector<TH2D*> thetaY_vs_time_mod_long_50ns_slices_[n_stn];
  vector<TH2D*> thetaY_vs_Y_slices_[n_stn];

  

  for (int i_stn = 0; i_stn < n_stn; i_stn++) { 

    momentum_[i_stn] = new TH1D((stns[i_stn]+"_Momentum").c_str(), ";Track momentum [MeV];Tracks", int(pmax), 0, pmax); 
    momY_[i_stn] = new TH1D((stns[i_stn]+"_MomentumY").c_str(), ";Track momentum Y [MeV];Tracks", 1000, -60, 60); 
    momX_[i_stn] = new TH1D((stns[i_stn]+"_MomentumX").c_str(), ";Track momentum X [MeV];Tracks", int(pmax), -pmax, pmax); 
    momZ_[i_stn] = new TH1D((stns[i_stn]+"_MomentumZ").c_str(), ";Track momentum Z [MeV];Tracks", int(pmax), -pmax, pmax); 
    decayZ_vs_decayX_[i_stn] = new TH2D((stns[i_stn]+"_DecayZ_vs_DecayX").c_str(), ";Decay vertex position X [mm];Decay vertex position Z [mm]", 800, -8000, 8000, 800, -8000, 8000);
    wiggle_[i_stn] = new TH1D((stns[i_stn]+"_Wiggle").c_str(), ";Decay time [#mus];Tracks", 2700, 0, 2700*T_c);
    wiggle_mod_[i_stn] = new TH1D((stns[i_stn]+"_Wiggle_Modulo").c_str(), ";t_{g#minus2}^{mod} [#mus];Tracks / 149.2 ns", 29, 0, g2Period); 
    wiggle_mod_long_[i_stn] = new TH1D((stns[i_stn]+"_Wiggle_Modulo_Long").c_str(), ";Time modulo [#mus];Tracks / 149.2 ns", 41*moduloMultiple, 0, g2Period*moduloMultiple); 
    thetaY_[i_stn] = new TH1D((stns[i_stn]+"_ThetaY").c_str(), ";#theta_{y} [mrad];Tracks", 1000, -TMath::Pi()*gmagic, TMath::Pi()*gmagic);
    thetaY_vs_time_[i_stn] = new TH2D((stns[i_stn]+"_ThetaY_vs_Time").c_str(), ";Decay time [#mus]; #theta_{y} [mrad] / 149.2 ns ", 2700, 0, 2700*T_c, 1000, -TMath::Pi()*gmagic, TMath::Pi()*gmagic);
    thetaY_vs_time_20ns_[i_stn] = new TH2D((stns[i_stn]+"_ThetaY_vs_Time_20ns").c_str(), ";Decay time [#mus]; #theta_{y} [mrad] / 20 ns ", 20000, 0, 20000*20e-3, 1000, -TMath::Pi()*gmagic, TMath::Pi()*gmagic);
    thetaY_vs_time_50ns_[i_stn] = new TH2D((stns[i_stn]+"_ThetaY_vs_Time_50ns").c_str(), ";Decay time [#mus]; #theta_{y} [mrad] / 50 ns ", 8000, 0, 8000*50e-3, 1000, -TMath::Pi()*gmagic, TMath::Pi()*gmagic);
    thetaY_vs_time_mod_[i_stn] = new TH2D((stns[i_stn]+"_ThetaY_vs_Time_Modulo").c_str(), ";t_{g#minus2}^{mod} [#mus]; #theta_{y} [mrad] / 149.2 ns", 29, 0, g2Period, 1000, -TMath::Pi()*gmagic, TMath::Pi()*gmagic);
    thetaY_vs_time_mod_50ns_[i_stn] = new TH2D((stns[i_stn]+"_ThetaY_vs_Time_Modulo_50ns").c_str(), ";t_{g#minus2}^{mod} [#mus]; #theta_{y} [mrad] / 50 ns", 87, 0, g2Period, 1000, -TMath::Pi()*gmagic, TMath::Pi()*gmagic);
    thetaY_vs_time_mod_20ns_[i_stn] = new TH2D((stns[i_stn]+"_ThetaY_vs_Time_Modulo_20ns").c_str(), ";t_{g#minus2}^{mod} [#mus]; #theta_{y} [mrad] / 20 ns", 174, 0, g2Period, 1000, -TMath::Pi()*gmagic, TMath::Pi()*gmagic);
    thetaY_vs_time_mod_long_[i_stn] = new TH2D((stns[i_stn]+"_ThetaY_vs_Time_Modulo_Long").c_str(), ";Time modulo [#mus]; #theta_{y} [mrad] / 149.2 ns", 29*moduloMultiple, 0, g2Period*moduloMultiple, 1000, -TMath::Pi()*gmagic, TMath::Pi()*gmagic);
    thetaY_vs_time_mod_long_20ns_[i_stn] = new TH2D((stns[i_stn]+"_ThetaY_vs_Time_Modulo_Long_20ns").c_str(), ";Time modulo [#mus]; #theta_{y} [mrad] / 20 ns", 174*moduloMultiple, 0, g2Period*moduloMultiple, 1000, -TMath::Pi()*gmagic, TMath::Pi()*gmagic);
    thetaY_vs_time_mod_long_50ns_[i_stn] = new TH2D((stns[i_stn]+"_ThetaY_vs_Time_Modulo_Long_50ns").c_str(), ";Time modulo [#mus]; #theta_{y} [mrad] / 50 ns", 87*moduloMultiple, 0, g2Period*moduloMultiple, 1000, -TMath::Pi()*gmagic, TMath::Pi()*gmagic);
    thetaY_vs_momentum_[i_stn] = new TH2D((stns[i_stn]+"_ThetaY_vs_Momentum").c_str(), ";Decay vertex momentum [MeV]; #theta_{y} [mrad] / 10 MeV ", 300, 0, 3000, 1000, -TMath::Pi()*boostFactor, TMath::Pi()*boostFactor);
    thetaY_vs_Y_[i_stn] = new TH2D((stns[i_stn]+"_ThetaY_vs_Y").c_str(), ";Decay vertex momentum [MeV];Decay y-position [mm]", 48, -60, -60, 1260, -1575, -1575);

        // Slice momentum
    for ( int i_slice = 0; i_slice < nSlices; i_slice++ ) { 

      int lo = 0 + i_slice*step; 
      int hi = step + i_slice*step;

      TH1D *h_p_mom_slices = new TH1D((stns[i_stn]+"_Momentum_"+std::to_string(lo)+"_"+std::to_string(hi)).c_str(), ";Track momentum [MeV];Tracks",  int(pmax), 0, pmax);
      p_mom_slices_[i_stn].push_back(h_p_mom_slices);

      TH1D *h_pY_mom_slices = new TH1D((stns[i_stn]+"_MomentumY_"+std::to_string(lo)+"_"+std::to_string(hi)).c_str(), ";Track momentum Y MeV];Tracks",  1000, -60, 60);
      pY_mom_slices_[i_stn].push_back(h_pY_mom_slices);

      TH1D *h_Y_mom_slice = new TH1D((stns[i_stn]+"_Y_"+std::to_string(lo)+"_"+std::to_string(hi)).c_str(), ";Vertical decay position [mm];Tracks",  180, -60, 60);
      Y_mom_slices_[i_stn].push_back(h_Y_mom_slice);

      TH2D *h_thetaY_vs_time_mod_slice = new TH2D((stns[i_stn]+"_ThetaY_vs_Time_Modulo_"+std::to_string(lo)+"_"+std::to_string(hi)).c_str(), ";t_{g#minus2}^{mod} [#mus]; #theta_{y} [mrad] / 149.2 ns", 29, 0, g2Period, 1000, -TMath::Pi()*gmagic, TMath::Pi()*gmagic);
      thetaY_vs_time_mod_slices_[i_stn].push_back(h_thetaY_vs_time_mod_slice);

      TH2D *h_thetaY_vs_time_mod_20ns_slice = new TH2D((stns[i_stn]+"_ThetaY_vs_Time_Modulo_20ns_"+std::to_string(lo)+"_"+std::to_string(hi)).c_str(), ";t_{g#minus2}^{mod} [#mus]; #theta_{y} [mrad] / 20 ns", 174, 0, g2Period, 1000, -TMath::Pi()*gmagic, TMath::Pi()*gmagic);
      thetaY_vs_time_mod_20ns_slices_[i_stn].push_back(h_thetaY_vs_time_mod_20ns_slice);

      TH2D *h_thetaY_vs_time_mod_50ns_slice = new TH2D((stns[i_stn]+"_ThetaY_vs_Time_Modulo_50ns_"+std::to_string(lo)+"_"+std::to_string(hi)).c_str(), ";t_{g#minus2}^{mod} [#mus]; #theta_{y} [mrad] / 50 ns", 87, 0, g2Period, 1000, -TMath::Pi()*gmagic, TMath::Pi()*gmagic);
      thetaY_vs_time_mod_50ns_slices_[i_stn].push_back(h_thetaY_vs_time_mod_50ns_slice);

      TH2D *h_thetaY_vs_time_mod_long_slice = new TH2D((stns[i_stn]+"_ThetaY_vs_Time_Modulo_Long_"+std::to_string(lo)+"_"+std::to_string(hi)).c_str(), ";t_{g#minus2}^{mod} [#mus]; #theta_{y} [mrad] / 149.2 ns", 29*moduloMultiple, 0, g2Period*moduloMultiple, 1000, -TMath::Pi()*gmagic, TMath::Pi()*gmagic);
      thetaY_vs_time_mod_long_slices_[i_stn].push_back(h_thetaY_vs_time_mod_long_slice);

      TH2D *h_thetaY_vs_time_mod_long_20ns_slice = new TH2D((stns[i_stn]+"_ThetaY_vs_Time_Modulo_Long_20ns_"+std::to_string(lo)+"_"+std::to_string(hi)).c_str(), ";t_{g#minus2}^{mod} [#mus]; #theta_{y} [mrad] / 20 ns", 174*moduloMultiple, 0, g2Period*moduloMultiple, 1000, -TMath::Pi()*gmagic, TMath::Pi()*gmagic);
      thetaY_vs_time_mod_long_20ns_slices_[i_stn].push_back(h_thetaY_vs_time_mod_long_20ns_slice);

      TH2D *h_thetaY_vs_time_mod_long_50ns_slice = new TH2D((stns[i_stn]+"_ThetaY_vs_Time_Modulo_Long_50ns_"+std::to_string(lo)+"_"+std::to_string(hi)).c_str(), ";t_{g#minus2}^{mod} [#mus]; #theta_{y} [mrad] / 50 ns", 87*moduloMultiple, 0, g2Period*moduloMultiple, 1000, -TMath::Pi()*gmagic, TMath::Pi()*gmagic);
      thetaY_vs_time_mod_long_50ns_slices_[i_stn].push_back(h_thetaY_vs_time_mod_long_50ns_slice);

      TH1D *h_thetaY_mom_slice = new TH1D((stns[i_stn]+"_ThetaY_"+std::to_string(lo)+"_"+std::to_string(hi)).c_str(), ";#theta_{y} [mrad];Tracks",  500, -TMath::Pi()*gmagic, TMath::Pi()*gmagic);
      thetaY_mom_slices_[i_stn].push_back(h_thetaY_mom_slice);

      TH2D *h_thetaY_vs_Y_slice = new TH2D((stns[i_stn]+"_ThetaY_vs_Y").c_str(), ";Decay vertex momentum [MeV];Decay y-position [mm]", 48, -60, -60, 1260, -1575, -1575);
      h_thetaY_vs_Y_slices_[i_stn].push_back(h_thetaY_vs_Y_slice);

    }

  }

  // Get branches (using header file)
  InitBranches br(tree);

  double targetPerc = 0;
  int64_t nEntries = tree->GetEntries();

  double muAngleMax = 0;

  int64_t counter = 0;

  // For FR randomisation
  TRandom3 *rand = new TRandom3(12345);

  for(int64_t entry = 0; entry < nEntries; entry++) {

    tree->GetEntry(entry);

    // Get variables
    double time = br.posiInitTime * 1e-3; // us
    time = RandomisedTime(rand, time); // randomise out the FR

    // Positron world momentum 
    TVector3 eMom(br.posiInitPX, br.posiInitPY, br.posiInitPZ); 
    TVector3 ePos(br.posiInitPosX, br.posiInitPosY, br.posiInitPosZ);
    TVector3 muPol(br.muDecayPolX, br.muDecayPolY, br.muDecayPolZ);

    // Positron momentum in the lab frame
    // double p_world = br.posiInitP;

    double g2ModTime = ModTime(time);
    double longModTime = ModTime(time, moduloMultiple);

    double y = ePos.Y(); 

    // RingAngle is angle from x axis, from 0 to 2pi
    double ringAngle = atan2(br.posiInitPosZ, br.posiInitPosX);    
    if (ringAngle < 0) ringAngle += TMath::TwoPi();

    // Positron angle around the ring momentum AAR
    // Z is tangential to magic mom at x and z of decay (Figure 2 of Debevec note)

    // Muon rest frame
    if(boost) {

      // Rotate into AAR
      eMom.RotateY(ringAngle);
      ePos.RotateY(ringAngle);
      muPol.RotateY(ringAngle);

      //rotation not perfect, so if original y component was 0 force that to be the case:
      if (fabs(muPol.y()) < 1E-10) {
	      muPol = TVector3(muPol.x(), 0.0, muPol.z());
	      muPol = muPol.Unit();
      }

      double muP = br.muDecayP;
      double eP = br.posiInitP;
      double muE_lab = sqrt(mMu*mMu + muP*muP);
      double posiE_lab = sqrt(eMass*eMass + eP*eP);
      double gamma = sqrt(1.0 + pow( muP/mMu, 2 )); 

      // Construct muon momentum vector and rotate it
      TVector3 muMom(br.muDecayPX, br.muDecayPY, br.muDecayPZ);
      muMom.RotateY(ringAngle);

      // Construct 4-vector and boost it into the rest frame
      ROOT::Math::PxPyPzEVector muMomE_lab(muMom.x(), muMom.y(), muMom.z(), muE_lab);
      ROOT::Math::XYZVector boost = muMomE_lab.BoostToCM();

      // Get boost vector as a lorentz vector
      TVector3 boostToCM(boost.x(), boost.y(), boost.z());

      // Make positron momentum 4 vector in lab, and get boost vector as a TVector3 vector
      TLorentzVector posiMomE_lab(eMom.x(), eMom.y(), eMom.z(), posiE_lab);

      // Apply boost to positron lab vector to get it in MRF 1, using TLorentzVectors. Convert to normal TVector3 at end 
      TLorentzVector posiMomE_MRF = posiMomE_lab;
      posiMomE_MRF.Boost(boostToCM);

      TVector3 posiMom_MRF(posiMomE_MRF.Px(), posiMomE_MRF.Py(), posiMomE_MRF.Pz());

      eMom = posiMom_MRF; 


    } 

    /////////////////////////////////
    //                             //
    // Define the vertical angle   //
    //                             //
    /////////////////////////////////

    // We need to do this in a way that doesn't involve the z-component of momentum
    // It should be an entirely tranvserse quantity 

    double px = eMom.X();
    double py = eMom.Y();
    double pz = eMom.Z();
    double pT = sqrt( pow(px, 2) + pow(py, 2) );
    double p = eMom.Mag();

    double theta_y = asin(py/p);

    double alpha = muPol.Angle(eMom);

    ////////////////////////////////////////////////////////////////////////////////////////////////

    // convert into mrad (always forget to do this so I'm putting it here)
    theta_y = theta_y * 1e3;

    // cout<<"\ntheta_y = "<<theta_y<<endl;
    ////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////

    // Correct offset (no time dependance here)
    if(verticalOffsetCorrection) {

      double theta_y_offset = verticalOffsetHist->GetBinContent(verticalOffsetHist->FindBin(p));
      theta_y = theta_y - theta_y_offset;

    }

    // Loop through stations for station dependant correction 

    for(auto& stn : stns) { 

      int stn_id = -1;

      if(stn=="S12") stn_id = 0;
      else if(stn=="S18") stn_id = 1;
      else if(stn=="S12S18") stn_id = 2; 
      else cerr<<"Station not recognised"; 

      //cout<<stn_id<<endl;

      // Apply momentum dependant acceptance weighting

      if(true) { // this can only be true!

        // Slice momentum 
        for ( int i_slice = 0; i_slice < nSlices; i_slice++ ) { 

          int lo = 0 + i_slice*step; 
          int hi = step + i_slice*step;

          // What is the nearest bin centre?
          if(p >= double(lo) && p < double(hi)) { 

            TH2D *acceptanceHist = (TH2D*)acceptanceFile->Get(("AcceptanceWeighting/MomBins/"+stn+"_WeightMap_"+to_string(lo)+"_"+to_string(hi)).c_str());
            //cout<<acceptanceHist<<endl;
            double binCentre = (lo+hi)/2;
            double new_theta_y = 0; 

            if(p<binCentre) { // Get next lowest bin 

              TH2D *acceptanceHistLo = (TH2D*)acceptanceFile->Get(("AcceptanceWeighting/MomBins/"+stn+"_WeightMap_"+to_string(lo-step)+"_"+to_string(hi-step)).c_str());
              new_theta_y = AcceptanceWeightedAngleWithInterpolation(acceptanceHist, acceptanceHistLo, theta_y, y);

              //cout<<"---> LO: \np = "<<p<<"\nbin centre = "<<binCentre<<"\nnew theta_y = "<<new_theta_y<<endl;

            } else if(p>=binCentre) { // Get next highest bin 

              TH2D *acceptanceHistHi = (TH2D*)acceptanceFile->Get(("AcceptanceWeighting/MomBins/"+stn+"_WeightMap_"+to_string(lo+step)+"_"+to_string(hi+step)).c_str());
              new_theta_y = AcceptanceWeightedAngleWithInterpolation(acceptanceHist, acceptanceHistHi, theta_y, y);

              //cout<<"---> HI: \np = "<<p<<"\nbin centre = "<<binCentre<<"\nnew theta_y = "<<new_theta_y<<endl;

            }

            theta_y = new_theta_y;

          } // momentum bin 'if' statement

        } // slice momentum

      } // acc corr

      // cout<<"theta_y = "<<theta_y<<endl;

      // Time cuts
      if(timeCuts && time < g2Period*7) continue;      

      // ------------- Fill histograms -------------

      decayZ_vs_decayX_[stn_id]->Fill(ePos.X(), ePos.Z());

      // g-2 cuts. See Fienberg thesis figure 2.10
      if(p > 1900  && p < pmax*momBoostFactor) {
        
        wiggle_[stn_id]->Fill(time);
        wiggle_mod_[stn_id]->Fill(g2ModTime);
        if(time>8*g2Period) wiggle_mod_long_[stn_id]->Fill(longModTime);
      } 

      momY_[stn_id]->Fill(py);
      momX_[stn_id]->Fill(px);
      momZ_[stn_id]->Fill(pz);

      // EDM cuts
      if(momCuts && p > pLo*momBoostFactor && p < pHi*momBoostFactor) { 

        momentum_[stn_id]->Fill(p);
        thetaY_[stn_id]->Fill(theta_y);
        thetaY_vs_time_[stn_id]->Fill(time, theta_y);
        thetaY_vs_time_20ns_[stn_id]->Fill(time, theta_y);
        thetaY_vs_time_50ns_[stn_id]->Fill(time, theta_y);
        thetaY_vs_time_mod_[stn_id]->Fill(g2ModTime, theta_y);
        thetaY_vs_time_mod_50ns_[stn_id]->Fill(g2ModTime, theta_y);
        thetaY_vs_momentum_[stn_id]->Fill(p, theta_y);
        thetaY_vs_Y_[stn_id]->Fill(theta_y, y);

        if(time > 8*g2Period) {

          thetaY_vs_time_mod_long_[stn_id]->Fill(longModTime, theta_y);
          thetaY_vs_time_mod_long_20ns_[stn_id]->Fill(longModTime, theta_y); 
          thetaY_vs_time_mod_long_50ns_[stn_id]->Fill(longModTime, theta_y);   

        }  

      } else if(!momCuts) { 

        momentum_[stn_id]->Fill(p);
        thetaY_[stn_id]->Fill(theta_y);
        thetaY_vs_time_[stn_id]->Fill(time, theta_y);
        thetaY_vs_time_20ns_[stn_id]->Fill(time, theta_y);
        thetaY_vs_time_50ns_[stn_id]->Fill(time, theta_y);
        thetaY_vs_time_mod_[stn_id]->Fill(g2ModTime, theta_y);
        thetaY_vs_time_mod_50ns_[stn_id]->Fill(g2ModTime, theta_y);
        thetaY_vs_momentum_[stn_id]->Fill(p, theta_y);
        thetaY_vs_Y_[stn_id]->Fill(theta_y, y);

        if(time > 8*g2Period) {
          thetaY_vs_time_mod_long_[stn_id]->Fill(longModTime, theta_y);
          thetaY_vs_time_mod_long_20ns_[stn_id]->Fill(longModTime, theta_y); 
          thetaY_vs_time_mod_long_50ns_[stn_id]->Fill(longModTime, theta_y);    
        }  


      }

      // Slice momentum 
      for ( int i_slice = 0; i_slice < nSlices; i_slice++ ) { 

        int lo = 0 + i_slice*step; 
        int hi = step + i_slice*step;

        if(p >= double(lo) && p < double(hi)) { 

          thetaY_vs_time_mod_slices_[stn_id].at(i_slice)->Fill(g2ModTime, theta_y);
          thetaY_vs_time_mod_20ns_slices_[stn_id].at(i_slice)->Fill(g2ModTime, theta_y);
          thetaY_vs_time_mod_50ns_slices_[stn_id].at(i_slice)->Fill(g2ModTime, theta_y);

        if(time > 8*g2Period) {
          thetaY_vs_time_mod_long_slices_[stn_id].at(i_slice)->Fill(longModTime, theta_y);
          thetaY_vs_time_mod_long_20ns_slices_[stn_id].at(i_slice)->Fill(longModTime, theta_y);
          thetaY_vs_time_mod_long_50ns_slices_[stn_id].at(i_slice)->Fill(longModTime, theta_y);    
        }  

        // Other scans 
        thetaY_mom_slices_[stn_id].at(i_slice)->Fill(theta_y);
        Y_mom_slices_[stn_id].at(i_slice)->Fill(y);
        pY_mom_slices_[stn_id].at(i_slice)->Fill(py);
        p_mom_slices_[stn_id].at(i_slice)->Fill(p);
        thetaY_vs_y_slices_[stn_id].at(i_slice)->Fill(theta_y, y);

        }

      }

    } // stn loop

    if(100*float(entry) / nEntries > targetPerc) {
      cout << Form("Processed %.1f%%", 100*float(entry)/nEntries) << endl;
      targetPerc += 10;
    }

    // Get max muon angle
    if(br.muDecayPolY > muAngleMax) muAngleMax = br.muDecayPolY;

  }

  cout<<"Muon max angle:\t"<<muAngleMax<<" radians"<<endl;

  // Write histograms 
  output->mkdir("SimultaneousAnalysis"); output->mkdir("MomentumBinnedAnalysis");  

  for (int i_stn = 0; i_stn < n_stn; i_stn++) { 

    output->cd("SimultaneousAnalysis");

    momentum_[i_stn]->Write();
    wiggle_[i_stn]->Write();
    wiggle_mod_[i_stn]->Write();
    wiggle_mod_long_[i_stn]->Write();
    thetaY_[i_stn]->Write();
    thetaY_vs_time_[i_stn]->Write();
    thetaY_vs_time_20ns_[i_stn]->Write(); 
    thetaY_vs_time_50ns_[i_stn]->Write(); 
    thetaY_vs_time_mod_[i_stn]->Write();
    thetaY_vs_time_mod_20ns_[i_stn]->Write();
    thetaY_vs_time_mod_50ns_[i_stn]->Write();
    thetaY_vs_time_mod_long_[i_stn]->Write();
    thetaY_vs_time_mod_long_20ns_[i_stn]->Write();
    thetaY_vs_time_mod_long_50ns_[i_stn]->Write();
    decayZ_vs_decayX_[i_stn]->Write();
    momX_[i_stn]->Write();
    momY_[i_stn]->Write();
    momZ_[i_stn]->Write();
    thetaY_vs_momentum_[i_stn]->Write();

    for ( int i_slice = 0; i_slice < nSlices; i_slice++ ) {

      output->cd("MomentumBinnedAnalysis"); 

      thetaY_vs_time_mod_slices_[i_stn].at(i_slice)->Write();
      thetaY_vs_time_mod_20ns_slices_[i_stn].at(i_slice)->Write();
      thetaY_vs_time_mod_50ns_slices_[i_stn].at(i_slice)->Write();
      thetaY_vs_time_mod_long_slices_[i_stn].at(i_slice)->Write();
      thetaY_vs_time_mod_long_20ns_slices_[i_stn].at(i_slice)->Write();
      thetaY_vs_time_mod_long_50ns_slices_[i_stn].at(i_slice)->Write();
      thetaY_mom_slices_[i_stn].at(i_slice)->Write();
      Y_mom_slices_[i_stn].at(i_slice)->Write();
      pY_mom_slices_[i_stn].at(i_slice)->Write();
      p_mom_slices_[i_stn].at(i_slice)->Write();

    }

  }

  verticalOffsetFile->Close();
  acceptanceFile->Close();
  output->Close();

  return;

}*/

void RunNormally(TTree *tree, TFile *output, bool momCuts, bool timeCuts, bool boost, bool verticalOffsetCorrection, bool acceptanceCorr, string stn) {

  // Get vertical offset correction histograms
  TString verticalOffsetFileName = "correctionHists/verticalOffsetHists_allDecays_WORLD_250MeV_AQ.root";
  TFile *verticalOffsetFile = TFile::Open(verticalOffsetFileName);
  TH1D *verticalOffsetHist = (TH1D*)verticalOffsetFile->Get("VerticalOffsetHists/ThetaY_vs_p");

  TString acceptanceFileName = "correctionHists/acceptanceWeightingPlots.truth.root";
  TFile *acceptanceFile = TFile::Open(acceptanceFileName);

  // Set the number of periods for the longer modulo plots
  int moduloMultiple = 4; 

  // Somewhat arbitrary 
  double boostFactor = 5e3*(1/gmagic);
  double momBoostFactor = 1.;

  if(boost) { 
    boostFactor = 1.0e3;
    momBoostFactor = (1/(2*gmagic));
  }

  // ------ Book histograms -------

  TH1D *momentum = new TH1D("Momentum", ";Track momentum [MeV];Tracks", int(pmax), 0, pmax*momBoostFactor); 
  TH1D *momY = new TH1D("MomentumY", ";Track momentum Y [MeV];Tracks", 1000, -60, 60); 
  TH1D *momX = new TH1D("MomentumX", ";Track momentum X [MeV];Tracks", int(pmax), -pmax*momBoostFactor, pmax*momBoostFactor); 
  TH1D *momZ = new TH1D("MomentumZ", ";Track momentum Z [MeV];Tracks", int(pmax), -pmax*momBoostFactor, pmax*momBoostFactor); 
  TH2D *decayZ_vs_decayX = new TH2D("DecayZ_vs_DecayX", ";Decay vertex position X [mm];Decay vertex position Z [mm]", 800, -8000, 8000, 800, -8000, 8000);
  TH1D *wiggle = new TH1D("Wiggle", ";Decay time [#mus];Tracks", 2700, 0, 2700*T_c);
  TH1D *wiggle_mod = new TH1D("Wiggle_Modulo", ";t_{g#minus2}^{mod} [#mus];Tracks / 149.2 ns", 29, 0, g2Period); 
  TH1D *wiggle_mod_long = new TH1D("Wiggle_Modulo_Long", ";Time modulo [#mus];Tracks / 149.2 ns", 41*moduloMultiple, 0, g2Period*moduloMultiple); 
  TH1D *thetaY = new TH1D("ThetaY", ";#theta_{y} [mrad];Tracks", 1000, -TMath::Pi()*boostFactor, TMath::Pi()*boostFactor);
  TH2D *thetaY_vs_time = new TH2D("ThetaY_vs_Time", ";Decay time [#mus]; #theta_{y} [mrad] / 149.2 ns ", 2700, 0, 2700*T_c, 1000, -TMath::Pi()*boostFactor, TMath::Pi()*boostFactor);
  TH2D *thetaY_vs_time_20ns = new TH2D("ThetaY_vs_Time_20ns", ";Decay time [#mus]; #theta_{y} [mrad] / 20 ns ", 20000, 0, 20000*20e-3, 1000, -TMath::Pi()*boostFactor, TMath::Pi()*boostFactor);
  TH2D *thetaY_vs_time_50ns = new TH2D("ThetaY_vs_Time_50ns", ";Decay time [#mus]; #theta_{y} [mrad] / 50 ns ", 8000, 0, 8000*50e-3, 1000, -TMath::Pi()*boostFactor, TMath::Pi()*boostFactor);
  TH2D *thetaY_vs_time_mod = new TH2D("ThetaY_vs_Time_Modulo", ";t_{g#minus2}^{mod} [#mus]; #theta_{y} [mrad] / 149.2 ns", 29, 0, g2Period, 1000, -TMath::Pi()*boostFactor, TMath::Pi()*boostFactor);
  TH2D *thetaY_vs_time_mod_50ns = new TH2D("ThetaY_vs_Time_Modulo_50ns", ";t_{g#minus2}^{mod} [#mus]; #theta_{y} [mrad] / 50 ns", 87, 0, g2Period, 1000, -TMath::Pi()*boostFactor, TMath::Pi()*boostFactor);
  TH2D *thetaY_vs_time_mod_20ns = new TH2D("ThetaY_vs_Time_Modulo_20ns", ";t_{g#minus2}^{mod} [#mus]; #theta_{y} [mrad] / 20 ns", 174, 0, g2Period, 1000, -TMath::Pi()*boostFactor, TMath::Pi()*boostFactor);
  TH2D *thetaY_vs_time_mod_long = new TH2D("ThetaY_vs_Time_Modulo_Long", ";Time modulo [#mus]; #theta_{y} [mrad] / 149.2 ns", 29*moduloMultiple, 0, g2Period*moduloMultiple, 1000, -TMath::Pi()*boostFactor, TMath::Pi()*boostFactor);
  TH2D *thetaY_vs_time_mod_long_20ns = new TH2D("ThetaY_vs_Time_Modulo_Long_20ns", ";Time modulo [#mus]; #theta_{y} [mrad] / 20 ns", 174*moduloMultiple, 0, g2Period*moduloMultiple, 1000, -TMath::Pi()*boostFactor, TMath::Pi()*boostFactor);
  TH2D *thetaY_vs_time_mod_long_50ns = new TH2D("ThetaY_vs_Time_Modulo_Long_50ns", ";Time modulo [#mus]; #theta_{y} [mrad] / 50 ns", 87*moduloMultiple, 0, g2Period*moduloMultiple, 1000, -TMath::Pi()*boostFactor, TMath::Pi()*boostFactor);
  TH2D *thetaY_vs_momentum = new TH2D("ThetaY_vs_Momentum", ";Decay vertex momentum [MeV]; #theta_{y} [mrad] / 10 MeV ", 300, 0, 3000, 1000, -TMath::Pi()*boostFactor, TMath::Pi()*boostFactor);
  TH2D *thetaY_vs_Y = new TH2D("ThetaY_vs_Y", ";Decay vertex momentum [MeV];Decay y-position [mm]", 48, -60, -60, 1260, -1575, -1575);

  // Momentum scans
  vector<TH1D*> thetaY_mom_slices_;
  vector<TH1D*> Y_mom_slices_;
  vector<TH1D*> pY_mom_slices_;
  vector<TH1D*> p_mom_slices_;
  vector<TH2D*> thetaY_vs_Y_mom_slices_;
  vector<TH2D*> thetaY_vs_time_mod_slices_;
  vector<TH2D*> thetaY_vs_time_mod_20ns_slices_;
  vector<TH2D*> thetaY_vs_time_mod_50ns_slices_;
  vector<TH2D*> thetaY_vs_time_mod_long_slices_;
  vector<TH2D*> thetaY_vs_time_mod_long_20ns_slices_;
  vector<TH2D*> thetaY_vs_time_mod_long_50ns_slices_;
  

  // Slice momentum
  int step = 250 * momBoostFactor;
  int nSlices = (pmax/step) * momBoostFactor;

  // Slice momentum
  for ( int i_slice = 0; i_slice < nSlices; i_slice++ ) { 

    int lo = 0 + i_slice*step; 
    int hi = step + i_slice*step;

    TH1D *h_p_mom_slice = new TH1D(("Momentum_"+std::to_string(lo)+"_"+std::to_string(hi)).c_str(), ";Track momentum [MeV];Tracks",  int(pmax), 0, pmax*momBoostFactor);
    p_mom_slices_.push_back(h_p_mom_slice);

    TH1D *h_pY_mom_slice = new TH1D(("MomentumY_"+std::to_string(lo)+"_"+std::to_string(hi)).c_str(), ";Track momentum Y MeV];Tracks",  1000, -60, 60);
    pY_mom_slices_.push_back(h_pY_mom_slice);

    TH1D *h_Y_mom_slice = new TH1D(("Y_"+std::to_string(lo)+"_"+std::to_string(hi)).c_str(), ";Vertical decay position [mm];Tracks",  180, -60, 60);
    Y_mom_slices_.push_back(h_Y_mom_slice);

    TH2D *h_thetaY_vs_time_mod_slice = new TH2D(("ThetaY_vs_Time_Modulo_"+std::to_string(lo)+"_"+std::to_string(hi)).c_str(), ";t_{g#minus2}^{mod} [#mus]; #theta_{y} [mrad] / 149.2 ns", 29, 0, g2Period, 1000, -TMath::Pi()*boostFactor, TMath::Pi()*boostFactor);
    thetaY_vs_time_mod_slices_.push_back(h_thetaY_vs_time_mod_slice);

    TH2D *h_thetaY_vs_time_mod_20ns_slice = new TH2D(("ThetaY_vs_Time_Modulo_20ns_"+std::to_string(lo)+"_"+std::to_string(hi)).c_str(), ";t_{g#minus2}^{mod} [#mus]; #theta_{y} [mrad] / 20 ns", 174, 0, g2Period, 1000, -TMath::Pi()*boostFactor, TMath::Pi()*boostFactor);
    thetaY_vs_time_mod_20ns_slices_.push_back(h_thetaY_vs_time_mod_20ns_slice);

    TH2D *h_thetaY_vs_time_mod_50ns_slice = new TH2D(("ThetaY_vs_Time_Modulo_50ns_"+std::to_string(lo)+"_"+std::to_string(hi)).c_str(), ";t_{g#minus2}^{mod} [#mus]; #theta_{y} [mrad] / 50 ns", 87, 0, g2Period, 1000, -TMath::Pi()*boostFactor, TMath::Pi()*boostFactor);
    thetaY_vs_time_mod_50ns_slices_.push_back(h_thetaY_vs_time_mod_50ns_slice);

    TH2D *h_thetaY_vs_time_mod_long_slice = new TH2D(("ThetaY_vs_Time_Modulo_Long_"+std::to_string(lo)+"_"+std::to_string(hi)).c_str(), ";t_{g#minus2}^{mod} [#mus]; #theta_{y} [mrad] / 149.2 ns", 29*moduloMultiple, 0, g2Period*moduloMultiple, 1000, -TMath::Pi()*boostFactor, TMath::Pi()*boostFactor);
    thetaY_vs_time_mod_long_slices_.push_back(h_thetaY_vs_time_mod_long_slice);

    TH2D *h_thetaY_vs_time_mod_long_20ns_slice = new TH2D(("ThetaY_vs_Time_Modulo_Long_20ns_"+std::to_string(lo)+"_"+std::to_string(hi)).c_str(), ";t_{g#minus2}^{mod} [#mus]; #theta_{y} [mrad] / 20 ns", 174*moduloMultiple, 0, g2Period*moduloMultiple, 1000, -TMath::Pi()*boostFactor, TMath::Pi()*boostFactor);
    thetaY_vs_time_mod_long_20ns_slices_.push_back(h_thetaY_vs_time_mod_long_20ns_slice);

    TH2D *h_thetaY_vs_time_mod_long_50ns_slice = new TH2D(("ThetaY_vs_Time_Modulo_Long_50ns_"+std::to_string(lo)+"_"+std::to_string(hi)).c_str(), ";t_{g#minus2}^{mod} [#mus]; #theta_{y} [mrad] / 50 ns", 87*moduloMultiple, 0, g2Period*moduloMultiple, 1000, -TMath::Pi()*boostFactor, TMath::Pi()*boostFactor);
    thetaY_vs_time_mod_long_50ns_slices_.push_back(h_thetaY_vs_time_mod_long_50ns_slice);

    TH1D *h_thetaY_mom_slice = new TH1D(("ThetaY_"+std::to_string(lo)+"_"+std::to_string(hi)).c_str(), ";#theta_{y} [mrad];Tracks",  500, -TMath::Pi()*boostFactor, TMath::Pi()*boostFactor);
    thetaY_mom_slices_.push_back(h_thetaY_mom_slice);

    TH2D *thetaY_vs_Y_mom_slice = new TH2D(("ThetaY_vs_Y_"+std::to_string(lo)+"_"+std::to_string(hi)).c_str(), ";Decay vertex momentum [MeV];Decay y-position [mm]", 48, -60, -60, 1260, -1575, -1575);
    thetaY_vs_Y_mom_slices_.push_back(thetaY_vs_Y_mom_slice);

  }


  // Get branches (using header file)
  InitBranches br(tree);

  double targetPerc = 0;
  int64_t nEntries = tree->GetEntries();

  double muAngleMax = 0;

  int64_t counter = 0;

  // For FR randomisation
  TRandom3 *rand = new TRandom3(12345);
   
  for(int64_t entry = 0; entry < nEntries; entry++) {

    tree->GetEntry(entry);

    // Get variables
    double time = br.posiInitTime * 1e-3; // us
    time = RandomisedTime(rand, time); // randomise out the FR

    // Positron world momentum 
    TVector3 eMom(br.posiInitPX, br.posiInitPY, br.posiInitPZ); 
    TVector3 ePos(br.posiInitPosX, br.posiInitPosY, br.posiInitPosZ);
    TVector3 muPol(br.muDecayPolX, br.muDecayPolY, br.muDecayPolZ);

    // Positron momentum in the lab frame
    // double p_world = br.posiInitP;

    double g2ModTime = ModTime(time);
    double longModTime = ModTime(time, moduloMultiple);

    double y = ePos.Y(); 

    // RingAngle is angle from x axis, from 0 to 2pi
    double ringAngle = atan2(br.posiInitPosZ, br.posiInitPosX);    
    if (ringAngle < 0) ringAngle += TMath::TwoPi();

    // Positron angle around the ring momentum AAR
    // Z is tangential to magic mom at x and z of decay (Figure 2 of Debevec note)

    // Muon rest frame
    if(boost) {

      // Rotate into AAR
      eMom.RotateY(ringAngle);
      ePos.RotateY(ringAngle);
      muPol.RotateY(ringAngle);

      //rotation not perfect, so if original y component was 0 force that to be the case:
      if (fabs(muPol.y()) < 1E-10){
       muPol = TVector3(muPol.x(), 0.0, muPol.z());
       muPol = muPol.Unit();
      }

      double muP = br.muDecayP;
      double eP = br.posiInitP;
      double muE_lab = sqrt(mMu*mMu + muP*muP);
      double posiE_lab = sqrt(eMass*eMass + eP*eP);
      double gamma = sqrt(1.0 + pow( muP/mMu, 2 )); 

      // Construct muon momentum vector and rotate it
      TVector3 muMom(br.muDecayPX, br.muDecayPY, br.muDecayPZ);
      muMom.RotateY(ringAngle);

      // Construct 4-vector and boost it into the rest frame
      ROOT::Math::PxPyPzEVector muMomE_lab(muMom.x(), muMom.y(), muMom.z(), muE_lab);
      ROOT::Math::XYZVector boost = muMomE_lab.BoostToCM();

      // Get boost vector as a lorentz vector
      TVector3 boostToCM(boost.x(), boost.y(), boost.z());

      // Make positron momentum 4 vector in lab, and get boost vector as a TVector3 vector
      TLorentzVector posiMomE_lab(eMom.x(), eMom.y(), eMom.z(), posiE_lab);

      // Apply boost to positron lab vector to get it in MRF 1, using TLorentzVectors. Convert to normal TVector3 at end 
      TLorentzVector posiMomE_MRF = posiMomE_lab;
      posiMomE_MRF.Boost(boostToCM);

      TVector3 posiMom_MRF(posiMomE_MRF.Px(), posiMomE_MRF.Py(), posiMomE_MRF.Pz());

      eMom = posiMom_MRF; 


    } 

    /////////////////////////////////
    //                             //
    // Define the vertical angle   //
    //                             //
    /////////////////////////////////

    // We need to do this in a way that doesn't involve the z-component of momentum
    // It should be an entirely tranvserse quantity 

    double px = eMom.X();
    double py = eMom.Y();
    double pz = eMom.Z();
    double pT = sqrt( pow(px, 2) + pow(py, 2) );
    double p = eMom.Mag();

    double theta_y = asin(py/p);

    double alpha = muPol.Angle(eMom);

    ////////////////////////////////////////////////////////////////////////////////////////////////

    // convert into mrad (always forget to do this so I'm putting it here)
    theta_y = theta_y * 1e3;

    // Correct offset (no time dependance here)
    if(verticalOffsetCorrection) {

      double theta_y_offset = verticalOffsetHist->GetBinContent(verticalOffsetHist->FindBin(p));
      theta_y = theta_y - theta_y_offset;

    }
    
    // Apply momentum dependant acceptance weighting
    if(acceptanceCorr) {

      // Slice momentum 
      for ( int i_slice = 0; i_slice < nSlices; i_slice++ ) { 

        int lo = 0 + i_slice*step; 
        int hi = step + i_slice*step;

        // Linear interpolation 

        // What is the nearest bin centre?
        if(p >= double(lo) && p < double(hi)) { 

          TH2D *acceptanceHist = (TH2D*)acceptanceFile->Get(("AcceptanceWeighting/MomBins/"+stn+"_WeightMap_"+to_string(lo)+"_"+to_string(hi)).c_str());

          double binCentre = (lo+hi)/2;
          double new_theta_y = 0; 

          if(p<binCentre) { // Get next lowest bin 

            TH2D *acceptanceHistLo = (TH2D*)acceptanceFile->Get(("AcceptanceWeighting/MomBins/"+stn+"_WeightMap_"+to_string(lo-step)+"_"+to_string(hi-step)).c_str());
            new_theta_y = AcceptanceWeightedAngleWithInterpolation(acceptanceHist, acceptanceHistLo, theta_y, y);
          
            //cout<<"---> LO: \np = "<<p<<"\nbin centre = "<<binCentre<<"\nnew theta_y = "<<new_theta_y<<endl;

          } else if(p>=binCentre) { // Get next highest bin 

            TH2D *acceptanceHistHi = (TH2D*)acceptanceFile->Get(("AcceptanceWeighting/MomBins/"+stn+"_WeightMap_"+to_string(lo+step)+"_"+to_string(hi+step)).c_str());
            new_theta_y = AcceptanceWeightedAngleWithInterpolation(acceptanceHist, acceptanceHistHi, theta_y, y);

            //cout<<"---> HI: \np = "<<p<<"\nbin centre = "<<binCentre<<"\nnew theta_y = "<<new_theta_y<<endl;

          }

          theta_y = new_theta_y;

        }

      }

    }

    // Time cuts
    if(timeCuts && time < g2Period*7) continue; 

    decayZ_vs_decayX->Fill(ePos.X(), ePos.Z());

    // g-2 cuts. See Fienberg thesis figure 2.10
    if(p > 1900  && p < pmax*momBoostFactor) {
      wiggle->Fill(time);
      wiggle_mod->Fill(g2ModTime);
      if(time>8*g2Period) wiggle_mod_long->Fill(longModTime);
    } 

    momY->Fill(py);
    momX->Fill(px);
    momZ->Fill(pz);

    // EDM cuts
    if(momCuts && p > pLo*momBoostFactor && p < pHi*momBoostFactor) { 

      momentum->Fill(p);
      thetaY->Fill(theta_y);
      thetaY_vs_time->Fill(time, theta_y);
      thetaY_vs_time_20ns->Fill(time, theta_y);
      thetaY_vs_time_50ns->Fill(time, theta_y);
      thetaY_vs_time_mod->Fill(g2ModTime, theta_y);
      thetaY_vs_time_mod_50ns->Fill(g2ModTime, theta_y);
      thetaY_vs_momentum->Fill(p, theta_y);
      thetaY_vs_Y->Fill(y, theta_y);

      if(time > 8*g2Period) {
        thetaY_vs_time_mod_long->Fill(longModTime, theta_y);
        thetaY_vs_time_mod_long_20ns->Fill(longModTime, theta_y); 
        thetaY_vs_time_mod_long_50ns->Fill(longModTime, theta_y);    
      }  

    } else if(!momCuts) { 

      momentum->Fill(p);
      thetaY->Fill(theta_y);
      thetaY_vs_time->Fill(time, theta_y);
      thetaY_vs_time_20ns->Fill(time, theta_y);
      thetaY_vs_time_50ns->Fill(time, theta_y);
      thetaY_vs_time_mod->Fill(g2ModTime, theta_y);
      thetaY_vs_time_mod_50ns->Fill(g2ModTime, theta_y);
      thetaY_vs_momentum->Fill(p, theta_y);
      thetaY_vs_Y->Fill(y, theta_y);

      if(time > 8*g2Period) {
        thetaY_vs_time_mod_long->Fill(longModTime, theta_y);
        thetaY_vs_time_mod_long_20ns->Fill(longModTime, theta_y); 
        thetaY_vs_time_mod_long_50ns->Fill(longModTime, theta_y);    
      }  
 

    }

    // Slice momentum 
    for ( int i_slice = 0; i_slice < nSlices; i_slice++ ) { 

      int lo = 0 + i_slice*step; 
      int hi = step + i_slice*step;

      if(p >= double(lo) && p < double(hi)) { 

        thetaY_vs_time_mod_slices_.at(i_slice)->Fill(g2ModTime, theta_y);
        thetaY_vs_time_mod_20ns_slices_.at(i_slice)->Fill(g2ModTime, theta_y);
        thetaY_vs_time_mod_50ns_slices_.at(i_slice)->Fill(g2ModTime, theta_y);
      
        if(time > 8*g2Period) {
          thetaY_vs_time_mod_long_slices_.at(i_slice)->Fill(longModTime, theta_y);
          thetaY_vs_time_mod_long_20ns_slices_.at(i_slice)->Fill(longModTime, theta_y);
          thetaY_vs_time_mod_long_50ns_slices_.at(i_slice)->Fill(longModTime, theta_y);    
        }  

        // Other scans 
        thetaY_mom_slices_.at(i_slice)->Fill(theta_y);
        Y_mom_slices_.at(i_slice)->Fill(y);
        pY_mom_slices_.at(i_slice)->Fill(py);
        p_mom_slices_.at(i_slice)->Fill(p);
        thetaY_vs_Y_mom_slices_.at(i_slice)->Fill(y, theta_y);

      }

    }
 
    if(100*float(entry) / nEntries > targetPerc) {
      cout << Form("Processed %.1f%%", 100*float(entry)/nEntries) << endl;
      targetPerc += 10;
    }

    // Get max muon angle
    if(br.muDecayPolY > muAngleMax) muAngleMax = br.muDecayPolY;
         
  }

  cout<<"Muon max angle:\t"<<muAngleMax<<" radians"<<endl;
  // Write to output
  // Set output directory
  output->mkdir("SimultaneousAnalysis"); output->mkdir("MomentumBinnedAnalysis");

  output->cd("SimultaneousAnalysis");

  momentum->Write();
  wiggle->Write();
  wiggle_mod->Write();
  wiggle_mod_long->Write();
  thetaY->Write();
  thetaY_vs_time->Write();
  thetaY_vs_momentum->Write();
  thetaY_vs_time_20ns->Write(); 
  thetaY_vs_time_50ns->Write(); 
  thetaY_vs_time_mod->Write();
  thetaY_vs_time_mod_20ns->Write();
  thetaY_vs_time_mod_50ns->Write();
  thetaY_vs_time_mod_long->Write();
  thetaY_vs_time_mod_long_20ns->Write();
  thetaY_vs_time_mod_long_50ns->Write();
  decayZ_vs_decayX->Write();
  momX->Write();
  momY->Write();
  momZ->Write();
  thetaY_vs_Y->Write();

   for ( int i_slice = 0; i_slice < nSlices; i_slice++ ) {

    output->cd("MomentumBinnedAnalysis"); 

    thetaY_vs_time_mod_slices_.at(i_slice)->Write();
    thetaY_vs_time_mod_20ns_slices_.at(i_slice)->Write();
    thetaY_vs_time_mod_50ns_slices_.at(i_slice)->Write();
    thetaY_vs_time_mod_long_slices_.at(i_slice)->Write();
    thetaY_vs_time_mod_long_20ns_slices_.at(i_slice)->Write();
    thetaY_vs_time_mod_long_50ns_slices_.at(i_slice)->Write();
    thetaY_mom_slices_.at(i_slice)->Write();
    Y_mom_slices_.at(i_slice)->Write();
    pY_mom_slices_.at(i_slice)->Write();
    p_mom_slices_.at(i_slice)->Write();
    thetaY_vs_Y_mom_slices_.at(i_slice)->Write();
      
  }

  verticalOffsetFile->Close();
  acceptanceFile->Close();

  return;

}


int main(int argc, char *argv[]) {

  bool boost = false;
  bool momCuts = true; 
  bool timeCuts = true; 

  bool verticalOffsetCorr = false;
  bool acceptanceCorr = true;
  
  string inFileName = argv[1]; // "/pnfs/GM2/persistent/EDM/MC/dMu/TruthNTup/truthTrees.000.root";//
  string outFileName = argv[2]; //"tmp.root";
  //string config = argv[3]; // "Run-1a_250MeV_BQ";
  string stn = argv[3];

  string treeName = "phaseAnalyzer/g2phase";
  // Open tree and load branches
  TFile *fin = TFile::Open(inFileName.c_str());
  // Get tree
  TTree *tree = (TTree*)fin->Get(treeName.c_str());

  cout<<"\nOpened tree:\t"<<treeName<<" "<<tree<<" from file "<<inFileName<<" "<<fin<<endl;

  // Book output
  TFile *fout = new TFile(outFileName.c_str(),"RECREATE");

  // Fill histograms
  // RunNormally(TTree *tree, TFile *output, bool momCuts, bool timeCuts, bool boost, bool verticalOffsetCorrection, bool acceptanceCorr, string stn) {

  RunNormally(tree, fout, momCuts, timeCuts, boost, verticalOffsetCorr, acceptanceCorr, stn);
  //RunWithDataDrivenAcceptanceCorrection(tree, fout, config, momCuts, timeCuts, boost, verticalOffsetCorr, acceptanceCorr);
  
  fout->Close();
  fin->Close();

  cout<<"\nDone. Histogram written to:\t"<<outFileName<<" "<<fout<<endl;

  return 0;
}
